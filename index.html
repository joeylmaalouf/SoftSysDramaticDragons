<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <link rel="stylesheet" href="./stylesheets/pygment_trac.css">
    <link rel="stylesheet" href="./stylesheets/stylesheet.css">
    <title>SoftSys Dramatic Dragons</title>
  </head>

  <body>
    <div class="container">
      <section id="main_content">

        <br>
        <h4><a href="https://github.com/joeylmaalouf/SoftSysDramaticDragons/tree/master">Check out the repo!</a></h4>
        <h1>Project 1: Shell</h1>

        <h3>Joey Maalouf, Apurva Raman, Sean Carter</h3>

        <h2>Abstract</h2>
        <p>
          For this project, we aimed to create a functional <a href="http://linuxcommand.org/lc3_lts0010.php">shell</a> that would be able to run on a Linux system and accept the typical commands. Our implementation allows for many of the basic features that a user might expect, such as an interactive terminal mode, a batch file mode, configuration files, and aliases.
        </p>

        <h2>Background</h2>
        <p>
          Most of our research and understanding comes from the bash shell that is used by default in most Linux distributions. While trying to identify essential features, we referred to the <a href="https://www.gnu.org/software/bash/manual/bashref.html">bash reference manual</a> provided by gnu.org. We were also inspired by a number of assignments used at other colleges, such as <a href="https://www.cs.purdue.edu/homes/grr/SystemsProgrammingBook/Book/Chapter5-WritingYourOwnShell.pdf">this one</a> from Purdue University and <a href="http://pages.cs.wisc.edu/~dusseau/Classes/CS537-F07/Projects/P1/p1.html">this one</a> from the University of Wisconsin-Madison.
        </p>

        <h2>Implementation</h2>
        <p>
          Specifically, we wrote a program that can parse user input into tokens and search the filesystem for binaries matching the commands, running them with any supplied arguments and parameters. In between, it does things like check for custom "meta"-cases (like setting an alias or custom prompt), as well as un-alias any custom tokens into their original counterparts. It pulls its input from standard input in interactive mode, or a supplied file (or multiple) in batch mode.
        </p>
        <h3>Parsing</h3>
        <p>
          We identify commands by splitting input arguments into an array of character arrays, parsing the input one character at a time. Each character array is a single token (either the name of a command to run, or an argument for a previously-given command), so the array of arrays represents a complete command. Once the parser reaches a character that indicates the end of a command (e.g. ';'), it returns a flag that tells the rest of the code that it's time for execution (<a href="https://github.com/joeylmaalouf/SoftSysDramaticDragons/blob/master/project1/parsing.c#L38">parsing.c L38</a>).
        </p>
        <p>
          One of the consequences of parsing a single character at a time is that we had to keep track of a lot of state information, such as where the next character would go in the args array, or whether the character was in a comment or quote block. To hold all of this state information, we used a struct:
        </p>
<pre><code>typedef struct State {
  bool in_comment;
  bool in_quote;
  bool in_whitespace;
  int i_cmd;
  int i_char;
} State;</code></pre>
        <p>
          This strategy makes it easier to add new text parsing features, should any arise; all of the parsing features have been simplified into logic based on their boolean flags, so new ones would just slightly change decisions about when to write into the array and increment the command pointer. This is a useful improvement from our first state tracker, which was a large collection of static variables at the start of the function.
        </p>
        <h3>Execution</h3>
        <p>
          Execution is relatively simple; after properly parsing the arguments and checking for special cases (<a href="https://github.com/joeylmaalouf/SoftSysDramaticDragons/blob/master/project1/shell.c#L81">shell.c L81</a>), we fork a new process and execute the given array of strings as a command (<a href="https://github.com/joeylmaalouf/SoftSysDramaticDragons/blob/master/project1/shell.c#L29">shell.c L29</a>).
        </p>
        <h3>Aliases</h3>
        <p>
          Aliases are created as a set of key-value pairs with the aliases as the keys and the original commands and any additional arguments as the values (<a href="https://github.com/joeylmaalouf/SoftSysDramaticDragons/blob/master/project1/alias.c#L11">alias.c L11</a>). For each argument passed into the program, we check for any matching aliases (<a href="https://github.com/joeylmaalouf/SoftSysDramaticDragons/blob/master/project1/alias.c#L41">alias.c L41</a>) and replace them with their corresponding values. This is a linear search through the alias array, so it would be inefficient for large numbers of aliases, but we do not expect a given user to have enough aliases defined to have a significant impact on the speed. If an alias maps to a value with multiple tokens, additional space is allocated (<a href="https://github.com/joeylmaalouf/SoftSysDramaticDragons/blob/master/project1/alias.c#L49">alias.c L49</a>), all of the other arguments are shifted over in the array to make room for the additional tokens, and the alias is replaced (<a href="https://github.com/joeylmaalouf/SoftSysDramaticDragons/blob/master/project1/alias.c#L61">alias.c L61</a>).
        </p>
        <h3>Memory</h3>
        <p>
          All of the memory for the various arrays and structs is dynamically allocated (<a href="https://github.com/joeylmaalouf/SoftSysDramaticDragons/blob/master/project1/memory.c#L13">memory.c L13</a>) and freed (<a href="https://github.com/joeylmaalouf/SoftSysDramaticDragons/blob/master/project1/memory.c#L26">memory.c L26</a>), with the exception of the initial input buffer. This allows us to minimize wasted space in memory, at the expense of some processing overhead. Initially, we actually allocated everything statically, for ease of use. However, once we were comfortable with using the malloc function family, we were able to refactor the project to allocate memory dynamically instead (but not without some difficulty). Debugging segfaults can be unusually frustrating, since there's no meaningful error message other than "something related to memory went wrong".
        </p>

        <h2>Results</h2>
        <p>
          The first of our videos demonstrates usage of the .shellrc file, interactive mode, and aliases.
          <div style="position:relative;padding-bottom:60%"><iframe src="./images/interactive.mp4" frameborder="0" scrolling="no" width="100%" height="100%" style="position:absolute;top:0;left:0;" allowfullscreen></iframe></div>
          <br>
          Our second video shows how to use the batch file mode.
          <div style="position:relative;padding-bottom:60%"><iframe src="./images/batch.mp4" frameborder="0" scrolling="no" width="100%" height="100%" style="position:absolute;top:0;left:0;" allowfullscreen></iframe></div>
        </p>

      </section>
    </div>

  </body>
</html>
