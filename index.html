<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <link rel="stylesheet" href="./stylesheets/pygment_trac.css">
    <link rel="stylesheet" href="./stylesheets/stylesheet.css">
    <title>SoftSys Dramatic Dragons</title>
  </head>

  <body>
    <div class="container">
      <section id="main_content">

        <br>
        <h4><a href="https://github.com/joeylmaalouf/SoftSysDramaticDragons/tree/master">Check out the repo!</a></h4>
        <h1>Project 1: Shell</h1>

        <h3>Joey Maalouf, Apurva Raman, Sean Carter</h3>

        <h2>Abstract</h2>
        <p>
          For this project, we aimed to create a functional <a href="http://linuxcommand.org/lc3_lts0010.php">shell</a> that would be able to run on a Linux system and accept the typical commands. Our implementation allows for many of the basic features that a user might expect, such as an interactive terminal mode, a batch file mode, configuration files, and aliases.
        </p>

        <h2>Background</h2>
        <p>
          Most of our research and understanding comes from the <code>bash</code> shell that is used by default in most Linux distributions. While trying to identify essential features, we referred to the <a href="https://www.gnu.org/software/bash/manual/bashref.html">bash reference manual</a> provided by gnu.org. We were also inspired by a number of assignments used at other colleges, such as <a href="https://www.cs.purdue.edu/homes/grr/SystemsProgrammingBook/Book/Chapter5-WritingYourOwnShell.pdf">this one</a> from Purdue University and <a href="http://pages.cs.wisc.edu/~dusseau/Classes/CS537-F07/Projects/P1/p1.html">this one</a> from the University of Wisconsin-Madison.
        </p>

        <h2>Implementation</h2>
        <p>
          Specifically, we designed and implemented a program that would parse user input into tokens and search the filesystem for binaries matching the commands, running them with any supplied arguments and parameters. In between, it does things like check for custom "meta"-cases (like setting an alias or custom prompt), as well as un-alias any custom tokens into their original counterparts. It pulls its input from standard input in interactive mode, or a supplied file (or multiple) in batch mode.
        </p>
        <p>
          Parsing is done character-by-character, which allows for immediate execution upon reading any command-terminating character, but requires us to keep track of some state information. We did this with a struct holding booleans for parsing flags and integers for indices.
        </p>
        <p>
          All of the memory for the various arrays and structs is dynamically allocated and freed, with the exception of the initial input buffer. This allows us to minimize wasted space in memory, at the expense of some processing overhead.
        </p>

        <h2>Results</h2>
        <p>
          <!-- <img src="./images/usage.png" alt="Example Usage"> -->
          <div style="position:relative;padding-bottom:60%"><iframe src="./images/interactive.webm" frameborder="0" scrolling="no" width="100%" height="100%" style="position:absolute;top:0;left:0;" allowfullscreen></iframe></div>
          <div style="position:relative;padding-bottom:60%"><iframe src="./images/batch.webm"       frameborder="0" scrolling="no" width="100%" height="100%" style="position:absolute;top:0;left:0;" allowfullscreen></iframe></div>
        </p>

      </section>
    </div>

  </body>
</html>
